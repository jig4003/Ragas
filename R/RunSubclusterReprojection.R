#' Integrate and reproject sub-cluster analysis
#'
#' Combine dimension reduction and nearest neighbor data from child Seurat objects generated by subcluster analysis
#' and integrate with the parent Seurat object
#'
#' @param object The parent Seurat object
#' @param subclusters.list A list of child Seurat/Pi object to be combined
#' @param weight A numeric number between 0 and 1 indicating the weight to reserve nearest neighbor structures from the parent object (default: 1)
#' @param main.cluster.anno Additional cluster annotation for the parent Seurat object, such as user-annotated cluster identities
#' @param main.cluster.umap.config A list containing UMAP run parameters for main clusters
#' @param main.cluster.to.preserve Name of the metadata column containing main cluster identities that needs to be preserved during re-projection (default: seurat_clusters)
#' @param subcluster.colname Name of the metadata column of the child object contains subcluster identities (default: seurat_clusters)
#' @param subcluster.umap.config A list containing UMAP run parameters for subclusters per child object
#' @param diet.dimredc Whether to preserve a subset of DimReducs when running \code{DietSeurat} (default: pca, harmony, umap)
#' @param rp.reduction.name Name to store the re-projected dimension reduction object (default: rp)
#' @param rp.reduction.key Key for the re-projected dimension reduction object (default: RPUMAP_)
#' @param verbose Verbosity (default: TRUE)
#'
#' @return An updated parent Seurat object with two key modifications
#' \itemize{
#'  \item Added a new metadata column \code{subcluster_idents} to store subcluster identities
#'  \item Added a new dimension reduction object (default reduction: rp) with re-projected embedding
#'  }
#' @keywords internal
#'
#'@noRd

RunSubclusterReprojection <- function(object,
                                      subclusters.list,
                                      weight = 1,
                                      main.cluster.anno = NULL,
                                      main.cluster.umap.config = NULL,
                                      main.cluster.to.preserve = "seurat_clusters",
                                      subcluster.colname = "seurat_clusters",
                                      subcluster.umap.config = NULL,
                                      rp.reduction.name = "rp",
                                      rp.reduction.key = "RPUMAP_",
                                      verbose = TRUE
                                      ){
  ## parent object
  if(!is(object, "Seurat")){
    stop("Invalid input argument \"object\". Seurat object is required.")
  }else{
    parent.obj = object
    }

  if(is.null(main.cluster.anno)){
    if(verbose){
      message("No annotation data for main clusters. Proceed with \"seurat_clusters\"")
    }
    main.cluster.anno <- "seurat_clusters"
    }

  ## Create child object list for subclusters
  child.obj.list <-list()
  main.clusters.analyzed <- c()
  for(i in 1:length(subclusters.list)){
    obj.name <- names(subclusters.list)[i]
    child.obj.list[[obj.name]] <- list()
    ## load child objects
    if(length(subclusters.list[[i]]) > 1){
      if(verbose){message("Loading", subclusters.list[[i]][1],"...\n")}
      load(subclusters.list[[i]][1])
      input.obj <- get(subclusters.list[[i]][2])
    }else{
      input.obj <- get(subclusters.list[[i]][1])
    }
    ## check object type
    if(is(input.obj, "Seurat")){
      seurat.obj <- input.obj
    }else{
      if(is(input.obj, "Pi")){
        seurat.obj <- input.obj[["seurat.obj"]]
      }else{
        stop("Child object must be a Seurat or Pi object!")
      }
    }
    ## check cell overlap
    cells.child <- colnames(seurat.obj)
    cells.parent <- colnames(parent.obj)
    cells.common <- intersect(cells.child, cells.parent)
    if(length(cells.child) > length(cells.common)){
      message("The child object ", obj.name, " has ", length(cells.child), " cells, ", length(cells.common), " are found in the parent object.")
      message("Subsetting child object...\n")
      seurat.obj <- seurat.obj[, cells.common]
    }

    main.clusters.analyzed <- c(main.clusters.analyzed, unique(as.character(parent.obj[,colnames(seurat.obj)]$seurat_clusters)))
    # print(main.clusters.analyzed)
    child.obj.list[[obj.name]] <- seurat.obj
  }

  ## Create new metadata column "subcluster_idents"
  parent.obj$subcluster_idents <- "none"
  clusters.to.keep <- setdiff(levels(parent.obj$seurat_clusters), main.clusters.analyzed)
  # print(clusters.to.keep)
  if(length(clusters.to.keep) > 0){
    if(verbose){message("The following seurat_clusters are kept as-is without sub-cluster analysis: ", paste(clusters.to.keep,collapse = ", "))}
  }
  if(length(clusters.to.keep) > 0){
    for(i in 1:length(clusters.to.keep)){
      idx <- which(parent.obj$seurat_clusters == clusters.to.keep[i])
      parent.obj$subcluster_idents[idx] <- as.character(parent.obj[[main.cluster.anno, drop = TRUE]][idx])
    }
  }
  # print(unique(parent.obj$subcluster_idents))
  ## assign sub-cluster identities
  for(i in 1:length(child.obj.list)){
    idx <- match(colnames(child.obj.list[[i]]), colnames(parent.obj))
    parent.obj$subcluster_idents[idx] <- paste(names(child.obj.list)[i],child.obj.list[[i]][[subcluster.colname[names(child.obj.list)[i]], drop = TRUE]], sep = '-')

  }

  parent.obj <- subset(parent.obj, subset = subcluster_idents != 'none')

  ## make factor and order levels
  parent.obj$subcluster_idents <- factor(parent.obj$subcluster_idents, levels = sort(unique(parent.obj$subcluster_idents)))
  # print(table(parent.obj$subcluster_idents, parent.obj$seurat_clusters))

  parent.obj <- .RunReprojection(parent.obj,
                                 child.obj.list,
                                 mc.umap.config = main.cluster.umap.config,
                                 sc.umap.config = subcluster.umap.config,
                                 mc.cluster.to.preserve = main.cluster.to.preserve,
                                 w = weight,
                                 reduction.name = rp.reduction.name,
                                 reduction.key = rp.reduction.key,
                                 verbose = verbose)
  return(parent.obj)


}
